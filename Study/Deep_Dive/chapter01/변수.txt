 변수
 
 
 
 
 
 
 
 - 변수 선언 
 
 Q1 - 변수 선언에 의해 확보된 메모리 공간은 확보가 해재되기전까지는 
     누구도 확보된 메모리 공간을 사용할수 없도록 보호되므로 안전하게 사용할수있다. 
     (라는 말이있는데 굳이 안전하게 보호할필요?? 
     굳이 왜 확보된 메모리 공간을 사용할수없도록 하는거야? 
     내가 재사용을 위해 변수를 선언하는걸로아는데 보호?안전까지 고려해야하나?)

     --
     
     1 . 데이터 손상
         변수에 할당된 메모리가 보호되지 않으면,
         다른 코드나 프로세스가 그 메모리 영역을 수정할 수도 있다.
         이로 인해 원래 저장된 데이터가 손상되거나, 예상치 못한 값으로 변경될 수도 있는데
         이럴경우 내가 의도한 결과와 다른 비정상적인 작동을 보이게 될수있다.

    2. 메모리 충돌
      여러 프로세스나 쓰레드가 같은 메모리 영역을 동시에 접근하거나 수정하려고 할 경우,
      메모리 충돌이 발생할 수 있습니다. 이는 프로그램의 예측 불가능한 동작을 초래할 수 있으며, 심한 경우 시스템이 크래시될 수 있습니다.

    3. 보안 문제
       만약 메모리가 보호되지 않으면 악성 코드가 해당 메모리 영역에 접근해 민감한 정보를 읽거나 수정할 수 있습니다. 
       이는 보안 취약점으로 작용해 악의적인 공격에 노출될 수 있습니다.

    4. 프로그램 안정성
      프로그램은 변수에 저장된 데이터가 변경되지 않을 것이라는 가정하에 동작합니다.(const ? let?) 
      그러나 메모리가 보호되지 않으면 변수 값이 예상치 못하게 변경될 수 있어, 프로그램의 논리가 무너질 수 있습니다.
      
      -- Q1-1 (프로그램은 변수에 저장된 데이터가 변경되지 않을 것이라는 가정하에 동작합니다.)
           이문장 내가 아직 지식이 많지않아서 변수는 let은 변하고 const는 변하지 않는 상수잖아
           하지만 let같은 변수는 내가 변경할수도있는것을 암시해두고 작성하는거아니야? 변수란 변할수있는 값이잖아

      -- A 맞습니다! 변수는 본질적으로 "변할 수 있는 값"을 저장하기 위해 사용됩니다. 
           예를 들어, let으로 선언한 변수는 프로그램의 흐름에 따라 그 값이 변경될 수 있습니다.
           그렇다면 "프로그램은 변수에 저장된 데이터가 변경되지 않을 것이라는 가정하에 동작한다"는 문장이 혼란스러울 수 있습니다.
           여기서 중요한 부분은 **"변수에 저장된 데이터가 변경되지 않는다"**는 것이 아니라, **"예상하지 못한 방식으로 변경되지 않는다"**는 것입니다.

           프로그램 안정성과 메모리 보호

            따라서 "프로그램 안정성"이란, 변수가 변할 수 있지만 그 변동이 예상된 방식으로만 이루어지도록 하는 것을 의미합니다. 
            메모리 보호는 이런 예기치 않은 변경을 방지하여, 프로그램이 예상대로 동작하도록 보장해줍니다.
            즉, 변수의 값이 변할 수 있다는 점은 맞지만, 그 변화가 오직 프로그램이 의도한 방식으로만 일어나도록 보호하는 것이 중요합니다. 
            이로 인해 프로그램의 논리적 흐름이 보장되고, 예상치 못한 오류나 버그를 줄일 수 있습니다.

            결론적으로, 변수 선언에 의해 확보된 메모리 공간이 보호되는 것은 단순히 "안전"을 위한 것이 아니라, 
            프로그램이 의도한 대로 동작하고, 예기치 않은 오류나 보안 문제를 방지하기 위한 필수적인 조치입니다. 
            이러한 메모리 보호 덕분에 개발자는 프로그램의 안정성과 예측 가능성을 보장할 수 있습니다.

Q2 -- 확보가 해재된다는 말은 무슨마링야?
      
      A - "확보가 해제된다"는 말은 프로그래밍에서 특정 메모리 공간을 더 이상 사용하지 않겠다고 시스템에 알리고, 그 메모리 공간을 반환하는 과정을 의미합니다.

         - 왜 메모리 해제가 중요한가?
          메모리를 해제하지 않으면, 사용하지 않는 메모리 공간이 계속해서 점유된 상태로 남아 있게 되는데, 이를 "메모리 누수"라고 합니다. 
          메모리 누수가 발생하면 프로그램이 계속 실행될수록 사용 가능한 메모리가 줄어들어 시스템의 성능이 저하되거나, 
          심할 경우 시스템이 메모리 부족으로 인해 더 이상 정상적으로 동작하지 않게 될 수 있습니다.
          따라서, 필요 없는 메모리 공간은 적절히 해제해줘야 시스템의 메모리 자원을 효율적으로 사용할 수 있습니다.


----------------


변수 호이스팅

변수 선언 시 "암묵적인 초기화"에 대해서 var와 let은 다르게 동작합니다. 이 차이점은 JavaScript에서 중요한 개념 중 하나입니다. 아래에서 차이점을 설명드리겠습니다.

var의 암묵적 초기화
호이스팅(Hoisting): var로 선언된 변수는 호이스팅됩니다. 즉, 해당 변수 선언이 코드의 최상위로 끌어올려지는 것처럼 동작합니다.
초기화: 호이스팅 시, var 변수는 암묵적으로 undefined로 초기화됩니다. 즉, 변수 선언 전에 해당 변수를 참조하면 undefined 값을 갖습니다.

console.log(x); // undefined
var x = 10;

위 코드에서 var x = 10;이 실행되기 전에 x가 이미 undefined로 초기화됩니다. 그래서 변수 선언 전에 x를 참조하더라도 오류가 발생하지 않고, undefined를 반환합니다.

let의 암묵적 초기화
호이스팅(Hoisting): let으로 선언된 변수도 호이스팅됩니다. 하지만 let은 **일시적 사각지대(Temporal Dead Zone, TDZ)**에 의해 보호됩니다.
초기화: let 변수는 호이스팅 시 암묵적으로 초기화되지 않습니다. 선언이 실제로 코드에서 실행되기 전까지 변수는 초기화되지 않은 상태로 남아 있습니다. 초기화되기 전에 변수를 참조하려 하면 오류가 발생합니다.

console.log(y); // ReferenceError: Cannot access 'y' before initialization
let y = 10;

위 코드에서 let y = 10; 전에 y를 참조하려고 하면, ReferenceError가 발생합니다. 이는 y가 호이스팅되었지만 초기화되지 않았기 때문에 발생하는 오류입니다.

- 정리

var: 변수 선언이 호이스팅되며, 암묵적으로 undefined로 초기화됩니다. 따라서 초기화 전에 변수에 접근해도 오류가 발생하지 않습니다.(의도치 않은 전역 변수)
let: 변수 선언이 호이스팅되지만, 초기화되기 전까지 일시적 사각지대에 들어가게 됩니다. 이로 인해 초기화되기 전에 변수에 접근하려고 하면 ReferenceError가 발생합니다.
이 차이점은 let과 var가 동작하는 방식에서 중요한 부분을 차지하며, let을 사용하면 보다 안전한 코드를 작성할 수 있게 됩니다.







